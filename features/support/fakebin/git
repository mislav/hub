#!/bin/bash
# A wrapper for system git that prevents commands such as `clone` or `fetch` to be
# executed in testing. It logs commands to "~/.history" so afterwards it can be
# asserted that they ran.

global_args=()
while [ $# -gt 0 ]; do
  case "$1" in
    "--git-dir="* )
      global_args+=("$1")
      shift 1
      ;;
    -c | -C )
      global_args+=("$1" "$2")
      shift 2
      ;;
    * )
      break
      ;;
  esac
done

command="$1"
[ "$command" = "config" ] || echo git "$@" >> "$HOME"/.history

case "$command" in
  "--list-cmds="* )
    echo add
    echo branch
    echo commit
    ;;
  clone )
    url="${@: -1}"
    dir="$(basename "${url%.git}")"
    origin_name="origin"
    [ "$2" != "-o" ] || origin_name="$3"
    printf "Cloning into '%s'...\n" "$dir"
    mkdir -p "$dir" 2>/dev/null && ( cd "$dir"
      "$HUB_SYSTEM_GIT" init --quiet
      "$HUB_SYSTEM_GIT" commit --quiet --allow-empty -m 'initial commit'
      "$HUB_SYSTEM_GIT" remote add "$origin_name" "$url"
    )
    true
    ;;
  fetch | pull | push )
    # don't actually execute these commands
    exit
    ;;
  * )
    # note: `submodule add` also initiates a clone, but we work around it
    if [ "$command $2 $3" = "remote add -f" ]; then
      subcommand=$2
      shift 3
      exec "$HUB_SYSTEM_GIT" "${global_args[@]}" $command $subcommand "$@"
    else
      exec "$HUB_SYSTEM_GIT" "${global_args[@]}" "$@"
    fi
    ;;
  esac
